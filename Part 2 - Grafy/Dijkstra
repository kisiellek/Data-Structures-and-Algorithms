# ElogV //// (E+V)logV

# w praktyce użycie tutaj heapq jest szybsze

from heapq import heappop, heappush


def dijkstra(G, s):
    n = len(G)
    d = [float('inf')] * n
    parents = [None] * n

    PQ = [(0, s)]
    d[s]=0

    while len(PQ) > 0:
        u_w, u = heappop(PQ)

        # jeżeli b jest jakimś wierzchołkiem, do którego odległości szukamy
        # if u == b: break # jezeli wyciagniemy b to znaczy, ze byl juz przetworzony wczesniej (oraz wierzcholki z mniejszym od niego kosztem tez) i mozemy przerwac

        if u_w > d[u]: continue

        for v, w in G[u]:  # relax
            c = d[u] + w
            if d[v] > c:  # zbędny visited bo mamy bazowo inf w tablicy d
                d[v] = c
                parents[v] = u
                heappush(PQ, (c, v))  # (odl, numer)

    return d, parents


G1 = [  # (nr, waga)
    [(1,4),(2,1),(3,6)],
    [(0,4),(2,1),(4,1)],
    [(0,1),(1,1),(4,5)],
    [(0,6),(4,6)],
    [(1,1),(2,5),(3,6)]
]

print(dijkstra(G1,0))


# --------------------------------------------
# Dijkstra bez kolejki - O(V^2)
# Ma sens kiedy stosujemy reprezentację macierzową lub mamy do czynienia z grafem bliskim pełnego.

def dijkstra_m(G, s):
    n = len(G)
    d = [float('inf')] * n
    parents = [None] * n
    visited = [False] * n

    d[s] = 0

    for _ in range(n): # bo chcemy potencjalnie sprawdzić każdy wierzchołek nieodwiedzony
        # Szukamy nieodwiedzonego wierzchołka z najmnijeszym dystansem
        u = None
        for i in range(n):
            if not visited[i] and (u is None or d[i] < d[u]):
                u = i

        if d[u] == float('inf'): break

        visited[u] = True

        for v in range(n):
            w = G[u][v]
            if w:
                c = d[u] + w
                if d[v] > c:
                    d[v] = c
                    parents[v] = u

    return d, parents

G2 = [  # (nr, waga)
    [0,4,1,6,0],
    [4,0,1,0,1],
    [1,1,0,0,5],
    [6,0,0,0,6],
    [0,1,5,6,0]
]

print(dijkstra_m(G2,0))
