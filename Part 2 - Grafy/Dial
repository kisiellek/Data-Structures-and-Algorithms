from collections import deque
'''
Zamiast uÅ¼ywaÄ‡ kolejki priorytetowej (jak w Dijkstrze), Dial uÅ¼ywa tablicy kubeÅ‚kÃ³w (bucketÃ³w) â€“ czyli listy (np. deque), gdzie indeks kubeÅ‚ka to koszt dojÅ›cia.

PrzykÅ‚ad:
JeÅ›li wierzchoÅ‚ek 
ğ‘£
v ma odlegÅ‚oÅ›Ä‡ 5 od ÅºrÃ³dÅ‚a, to trafia do kubeÅ‚ka buckets[5].

KubeÅ‚ki sÄ… przeglÄ…dane od najmniejszego indeksu do najwiÄ™kszego, czyli od najmniejszego kosztu do wiÄ™kszych (tak jak w Dijkstrze wyciÄ…gamy z PQ najtaÅ„szy wierzchoÅ‚ek).

KROK PO KROKU
Wrzucasz wierzchoÅ‚ek do kubeÅ‚ka buckets[d[v]].

PrzeglÄ…dasz kubeÅ‚ki rosnÄ…co (d = 0, 1, 2, ...).

Z kubeÅ‚ka wyciÄ…gasz wszystkie wierzchoÅ‚ki o tym samym koszcie i relaksujesz ich sÄ…siadÃ³w.

Zaktualizowanych sÄ…siadÃ³w wrzucasz do kubeÅ‚kÃ³w o nowym koszcie.

To dziaÅ‚a jak â€wiadro na kaÅ¼dy kosztâ€ â€“ nie musisz szukaÄ‡ najmniejszego kosztu, bo kolejnoÅ›Ä‡ jest z gÃ³ry znana.'''
def dial(G, s):
    n = len(G)
    d = [float('inf')] * n
    parents = [None] * n

    max_w = max((w for u in G for _, w in u), default=0)
    buckets = [deque() for _ in range(n * max_w + 1)]  # maksymalny moÅ¼liwy dystans
    d[s] = 0
    buckets[0].append(s)

    idx = 0
    while idx < len(buckets):
        while idx < len(buckets) and not buckets[idx]:
            idx += 1
        if idx == len(buckets):
            break

        u = buckets[idx].popleft()

        if d[u] < idx:
            continue

        for v, w in G[u]:
            c = d[u] + w
            if d[v] > c:
                d[v] = c
                parents[v] = u
                buckets[c].append(v)

    return d, parents

G1 = [  # (nr, waga)
    [(1,4),(2,1),(3,6)],
    [(0,4),(2,1),(4,1)],
    [(0,1),(1,1),(4,5)],
    [(0,6),(4,6)],
    [(1,1),(2,5),(3,6)]
]

print(dial(G1,0))
