from collections import deque
'''
Zamiast używać kolejki priorytetowej (jak w Dijkstrze), Dial używa tablicy kubełków (bucketów) – czyli listy (np. deque), gdzie indeks kubełka to koszt dojścia.

Przykład:
Jeśli wierzchołek 
𝑣
v ma odległość 5 od źródła, to trafia do kubełka buckets[5].

Kubełki są przeglądane od najmniejszego indeksu do największego, czyli od najmniejszego kosztu do większych (tak jak w Dijkstrze wyciągamy z PQ najtańszy wierzchołek).

KROK PO KROKU
Wrzucasz wierzchołek do kubełka buckets[d[v]].

Przeglądasz kubełki rosnąco (d = 0, 1, 2, ...).

Z kubełka wyciągasz wszystkie wierzchołki o tym samym koszcie i relaksujesz ich sąsiadów.

Zaktualizowanych sąsiadów wrzucasz do kubełków o nowym koszcie.

To działa jak „wiadro na każdy koszt” – nie musisz szukać najmniejszego kosztu, bo kolejność jest z góry znana.'''
def dial(G, s):
    n = len(G)
    d = [float('inf')] * n
    parents = [None] * n

    max_w = max((w for u in G for _, w in u), default=0)
    buckets = [deque() for _ in range(n * max_w + 1)]  # maksymalny możliwy dystans
    d[s] = 0
    buckets[0].append(s)

    idx = 0
    while idx < len(buckets):
        while idx < len(buckets) and not buckets[idx]:
            idx += 1
        if idx == len(buckets):
            break

        u = buckets[idx].popleft()

        if d[u] < idx:
            continue

        for v, w in G[u]:
            c = d[u] + w
            if d[v] > c:
                d[v] = c
                parents[v] = u
                buckets[c].append(v)

    return d, parents

G1 = [  # (nr, waga)
    [(1,4),(2,1),(3,6)],
    [(0,4),(2,1),(4,1)],
    [(0,1),(1,1),(4,5)],
    [(0,6),(4,6)],
    [(1,1),(2,5),(3,6)]
]

print(dial(G1,0))
